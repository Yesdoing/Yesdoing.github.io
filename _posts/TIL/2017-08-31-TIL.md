---
layout: post
title: "2017-08-31 TIL"
categories:
  - TIL
tags:
  - JAVA
  - Effective Java 2/E
  - I/O
  - 예외처리
---

### 함수형 프로그래밍이란? - 요약
#### 출처 : [(번역) 함수형 프로그래밍이란 무엇인가? – Jooyung Han (한주영) – Medium](https://medium.com/@jooyunghan/함수형-프로그래밍이란-무엇인가-fab4e960d263)

* 함수형 프로그래밍은 자바의 람다와 스트림이 아니다.
* 함수형 프로그래밍은 자바스크립트의 클로져가 아니다.
* 자바와 자바스크립트는 함수형 프로그래밍이라 할 수 없다.
* 자바는 함수형프로그래밍의 반대편에 위치해있다.(객체가 상태와 행위를 가지는 것은 함수형프로그래밍에 맞지않다.)
* 자바스크립트는 함수형 프로그래밍의 지향점(Side-effect를 금지한다)에 맞지않는 개념은 적극 권장한다. - This의 사용(global에 접근할 수 있다는 것은 함수형프로그래밍이라 할수 없다.)
* 함수형 프로그래밍은 함수에서 side-effect를 발생하지 않게 하는 것이다. 그 의미는 입력과 출력을 정확하게 정의하는데서 시작한다.
* 함수의 Signature에 따른 것만 구현부에서 이용해야한다. 함수의 구현부에서 매개인자와 리턴 타입에 맞지 않는 다른 객체나 변수를 컨트롤하면 안된다.

### 함수의 Signature란?
* ```public boolean processMessage(Channel channel)```
* 함수의 정보를 표시하는것(리턴값의 데이터형, 인자의 갯수, 각 인자의 데이터형과 순서)
* 함수의 이름은 시그니처가 아니다!!! 위의 processMessage

### 이펙티브 자바 2/E - 규칙 8 Equals를 재정의할때는 일반규약을 따르라 까지 읽음.
> 이펙티브자바는 일단 막히는부분이 있더라도 이해할려하지말고 읽는다. 지금의 내 수준에서는 내가 알아보는부분을 보는 것을 좀 더 깊게 이해하고 모르는 부분은 일단 이렇게 쓰는거다라는 생각의 시작점만 만들자라는 생각을 읽는다. 그리고 읽고나서 다시 보지않고 생각나는 부분을 최대한 하루의 마지막 TIL에 작성한다.
  * 규칙 2 - 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라.
    * 생성자가 4개 이상이 될때는 Builder 패턴을 적용하는게 가독성과 코드 사용성 면에서 좋다.
  * 규칙 3 - private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라.
    * 싱글턴 패턴이란 하나의 객체만을 생성하여 그것을 이용하는 패턴이다.
    * enum은 내부적으로 하나의 객체만을 가질 수 있다. (하나의 고유객체를 가진다.)
  * 규칙 4 - 객체 생성을 막을때는 private 생성자를 이용하라.
    * 디폴트 생성자를 private로 선언하면 외부에서 그 객체의 생성을 하지 못한다.
    * 객체 생성을 막는 경우는 상태를 관리하지 않고 그저 일방적으로 기능을 제공해주는 API들에 많이 적용한다. (Utils 클래스같은..)
  * 규칙 5 - 불필요한 객체는 만들지 마라.
  * 규칙 6 - 유효기간이 지난 객체 참조는 폐기하라.
    * 가비지컬렉터(gc)가 자동으로 메모리를 해제 해주는 것은 맞지만 무의미한 메모리 선언은 메모리가 해제될때 까지 기다린다. (성능이 저하된다.)
    * 변수는 지역변수로 많이 사용하거나 사용하지 않는 전역 변수는 꼭 null을 대입해 주자. (가비지 컬렉터는 메모리의 연결이 끊어지면 수거한다.)
    * 수거하지 않는 예로는 ArrayList에 선언되고 reduce나 사용하지 않는 부분을 null처리 안하고 그냥 남겨두는 경우(InboxQueue)같은 경우..
  * 규칙 7 - 종료자 사용을 피하라.
    * 종료자의 정확한 시점을 모르면 다른 곳에서 오류가 발생할 수 있다. 종료자를 사용할 때는 정확히 사용되야하는 시점을 모르면 피하자.(물론 정확한 시점을 알면 해제 해주는것이 좋다.)
  * 규칙 8 - equals를 재정의 할때는 일반 규약을 따르라.
    * 객체가 똑같은지를 따질때는 보통 동치가 적용되는지 확인해야한다.
    * 자바에서는 객체가 상속을 하면 equals를 검증하기가 매우 까다롭다.
      ```
        class Point() {
          private int x;
          private int y;
          Point(int x, int y) {
            this.x = x;
            this.y = y;
          }
        }

        class ColorCircle extends Point {
          private String color;
          ColorCircle(int x, int y, String color) {
            super(x, y);
            this.color = color;
          }
        }
      ```

    * 위와 같은 코드에서 ColorCircle 객체와 Point객체에 equals를 적용하기란 불가능에 가깝다. 그래서 equals를 사용해야하는 경우에는 상속보다 구상(Component)로 구성하는게 좋다.
      ```
        class Point() {
          private int x;
          private int y;
          Point(int x, int y) {
            this.x = x;
            this.y = y;
          }
        }

        class ColorCircle {
          private String color;
          private Point point;
          ColorCircle(int x, int y, String color) {
            Point(x, y);
            this.color = color;
          }
        }
      ```      

### 예외처리  
  * 수요일에 구현한 웹 로또 프로그램에 예외처리 적용
  * model의 핵심로직에서 오류를 throw new 를 하고 Controller에서 catch하였다.
  * 하지만 컨트롤러에 너무 많은 try-catch가 발생하였다.
  * 이것은 Advice를 통해 추출할 수 있다.

### 자바 입출력 공부
  * 자바 7에서 Files라는 새로운 기능이 생겼다.(File의 상위호완)
  * 자바 5에서 NIO(New IO)라는 개념이 나왔는데 7에서는 NIO2가 나왔다.
  * 위 기능들은 자바의 신 vol. 2에서는 자세한 설명이 나와있지않다.(NIO가 비동기처리에 들어가는 것같다.)
  * vi 같은 콘솔 메모장을 구현하고 싶어 System.out의 출력을 수정하거나 System.in에서 next를 할때 초기값이 들어갔는지 Java Docs를 찾아봤으나 나오지않았다.
  * 해결을 하기위한 생각으로는 while문을 돌면서 Buffer를 처음에 출력하고 Buffer에 char단위로 글자를 하나씩 입력하는걸 반복하는것이다. 그리고 키보드 입력을 따로 맵핑하여 저장하여 메모장에 대한 컨트롤을 내가 직접 구현하는 것이다.
  * 이 사항에 대한 문제점은 커서의 구현을 어떻게 할것인가? 이다.(자바에서 커서 컨트롤에 관한 내용을 찾아봐야겠다.)
